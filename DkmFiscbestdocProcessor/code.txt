The following is a digest of the repository "DkmFiscbestdocProcessor".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: DkmFiscbestdocProcessor
Files Analyzed: 8
Total Text Size: 20.62 KB
Estimated Tokens (text only): ~5,366

--- DIRECTORY STRUCTURE ---
DkmFiscbestdocProcessor/
├── images/
│   └── dkm-logo.png [binary]
├── models/
│   ├── bestemmings_data.py
│   └── response_model.py
├── services/
│   ├── data_transformer.py
│   ├── pdf_generator.py
│   └── state_manager.py
├── __init__.py
└── function.json


--- FILE CONTENTS ---
============================================================
FILE: models/bestemmings_data.py
============================================================
from dataclasses import dataclass
from typing import List

@dataclass
class LineItem:
    """Individual line item from LINE_ITEMS JSON"""
    goederenomschrijving: str
    goederencode: str
    aantal_gewicht: float
    verkoopwaarde: float
    zendtarieflijnnummer: int
    netmass: float

@dataclass
class ClientInfo:
    """Client information"""
    naam: str
    straat_en_nummer: str
    postcode: str
    stad: str
    landcode: str
    plda_operatoridentity: str
    language: str

@dataclass
class BestemmingsData:
    """Complete Bestemmingsdocument data"""
    internfactuurnummer: int
    processfactuurnummer: int
    datum: str
    formatted_date: str
    client: ClientInfo
    mrn: str
    declarationid: int
    exportername: str
    reference: str
    line_items: List[LineItem]

============================================================
FILE: models/response_model.py
============================================================
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class PDFResponse:
    """Individual PDF response"""
    internfactuurnummer: int
    filename: str
    pdf_base64: str
    size_bytes: int
    metadata: Dict

@dataclass
class APIResponse:
    """Complete API response"""
    success: bool
    timestamp: str
    processed_count: int
    last_processed_id: int
    pdfs: List[Dict]
    errors: List[Dict]

============================================================
FILE: services/data_transformer.py
============================================================
import json
import logging
from datetime import datetime
from typing import List
from ..models.bestemmings_data import BestemmingsData, LineItem, ClientInfo

def transform_row(row: dict) -> BestemmingsData:
    """Transform API data to BestemmingsData"""
    try:
        # Parse LINE_ITEMS JSON
        line_items_str = row.get('LINE_ITEMS', '[]')
        line_items = json.loads(line_items_str)
        
        items = []
        for item in line_items:
            items.append(LineItem(
                goederenomschrijving=item.get('goederenomschrijving', ''),
                goederencode=item.get('goederencode', ''),
                aantal_gewicht=float(item.get('aantal_gewicht', 0)),
                verkoopwaarde=float(item.get('verkoopwaarde', 0)),
                zendtarieflijnnummer=int(item.get('zendtarieflijnnummer', 0)),
                netmass=float(item.get('netmass', 0))
            ))
        
        # Format date
        datum = row['DATUM']
        date_obj = datetime.strptime(datum, "%Y%m%d")
        formatted_date = date_obj.strftime("%d/%m/%Y")
        date_short = date_obj.strftime("%d/%m/%y")
        
        # Client info
        client = ClientInfo(
            naam=row['CLIENT_NAAM'],
            straat_en_nummer=row['CLIENT_STRAAT_EN_NUMMER'],
            postcode=row['CLIENT_POSTCODE'],
            stad=row['CLIENT_STAD'],
            landcode=row['CLIENT_LANDCODE'],
            plda_operatoridentity=row['CLIENT_PLDA_OPERATORIDENTITY'],
            language=row.get('CLIENT_LANGUAGE', 'EN')
        )
        
        # Clean reference
        reference = row.get('REFERENTIE_KLANT', '')
        reference = reference.replace('\r\n', '\n').replace('\r', '\n')
        
        return BestemmingsData(
            internfactuurnummer=row['INTERNFACTUURNUMMER'],
            processfactuurnummer=row['PROCESSFACTUURNUMMER'],
            datum=date_short,
            formatted_date=formatted_date,
            client=client,
            mrn=row.get('MRN', ''),
            declarationid=row['DECLARATIONID'],
            exportername=row.get('EXPORTERNAME', ''),
            reference=reference,
            line_items=items
        )
        
    except Exception as e:
        logging.error(f"Transform error: {str(e)}")
        raise

============================================================
FILE: services/pdf_generator.py
============================================================
import logging
import os
from reportlab.lib.pagesizes import A4, landscape
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from reportlab.lib import colors
from reportlab.platypus import Table, TableStyle
from reportlab.pdfbase.pdfmetrics import stringWidth
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from io import BytesIO


def generate_pdf(data) -> bytes:
    """Generate PDF matching exact design - ENGLISH ONLY"""
    try:
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=landscape(A4))
        width, height = landscape(A4)
        
        # Register fonts for exact matching
        try:
            # Try to use Arial as it's closer to the original
            pdfmetrics.registerFont(TTFont('Arial', 'Arial.ttf'))
            pdfmetrics.registerFont(TTFont('Arial-Bold', 'Arial Bold.ttf'))
            pdfmetrics.registerFont(TTFont('Arial-Italic', 'Arial Italic.ttf'))
            pdfmetrics.registerFont(TTFont('Arial-BoldItalic', 'Arial Bold Italic.ttf'))
            default_font = 'Arial'
        except:
            # Fallback to Helvetica
            default_font = 'Helvetica'
        
        y_position = height - 12*mm  # Adjusted for exact spacing
        
        y_position = draw_header(c, data, y_position, width, default_font)
        y_position = draw_title(c, y_position, width, default_font)
        y_position = draw_two_column_section(c, data, y_position, width, default_font)
        y_position = draw_table(c, data, y_position, width, default_font)
        
        c.save()
        pdf_bytes = buffer.getvalue()
        buffer.close()
        
        logging.info(f"✅ PDF generated: {len(pdf_bytes)} bytes")
        return pdf_bytes
        
    except Exception as e:
        logging.error(f"PDF generation failed: {str(e)}")
        raise


def draw_header(c: canvas.Canvas, data, y: float, width: float, font_family: str) -> float:
    """Draw header with exact positioning"""
    
    # LEFT: DKM Logo - exact positioning
    try:
        current_dir = os.path.dirname(os.path.dirname(__file__))
        logo_path = os.path.join(current_dir, "images", "dkm-logo.png")
        
        if os.path.exists(logo_path):
            c.drawImage(logo_path, 15*mm, y - 10*mm, 
                       width=35*mm, height=12*mm, 
                       preserveAspectRatio=True, mask='auto')
        else:
            c.setFont(f"{font_family}-Bold", 28)  # Smaller font size
            c.setFillColor(colors.HexColor('#E85D3F'))
            c.drawString(15*mm, y - 8*mm, "DKM")
            c.setFillColor(colors.black)
    except:
        c.setFont(f"{font_family}-Bold", 28)
        c.setFillColor(colors.HexColor('#E85D3F'))
        c.drawString(15*mm, y - 8*mm, "DKM")
        c.setFillColor(colors.black)
    
    # LEFT: Company info - exact spacing
    c.setFont(f"{font_family}-Bold", 10)  # Smaller font
    c.setFillColor(colors.black)
    c.drawString(15*mm, y - 18*mm, data.client.naam.upper())
    
    c.setFont(font_family, 8)  # Smaller font
    c.drawString(15*mm, y - 23*mm, data.client.straat_en_nummer.upper())
    c.drawString(15*mm, y - 28*mm, f"{data.client.postcode}    {data.client.stad.upper()}")
    c.drawString(15*mm, y - 33*mm, f"{data.client.landcode}  {data.client.plda_operatoridentity}")
    
    # RIGHT: DKM contact - exact positioning
    dkm_x = width - 65*mm
    c.setFont(f"{font_family}-Bold", 8)  # Smaller font
    c.drawString(dkm_x, y - 8*mm, "DKM-customs")
    c.setFont(font_family, 7)  # Smaller font
    c.drawString(dkm_x, y - 14*mm, "Noorderlaan 72- 2030 Antwerpen")
    c.drawString(dkm_x, y - 20*mm, "BE0796538660")
    
    return y - 38*mm  # Exact spacing


def draw_title(c: canvas.Canvas, y: float, width: float, font_family: str) -> float:
    """Draw title with exact positioning"""
    c.setFont(f"{font_family}-Bold", 9)  # Exact font size
    c.drawCentredString(width/2, y, "Declaration for VAT purposes according to :")
    
    y -= 3.5*mm  # Exact spacing
    c.setFont(f"{font_family}-Oblique", 7)  # Exact font size
    c.drawCentredString(width/2, y, "article 138, paragraph 1, directive 2006/112/EC")
    
    return y - 7*mm  # Exact spacing


def draw_two_column_section(c: canvas.Canvas, data, y: float, width: float, font_family: str) -> float:
    """
    LEFT: Gray Notice Box
    RIGHT: Declaration + Signature
    Exact positioning and sizing
    """
    
    # LEFT COLUMN: Notice Box - exact dimensions
    left_x = 15*mm
    box_width = 95*mm
    box_height = 22*mm  # Exact height
    box_y = y - box_height + 3*mm  # Exact positioning
    
    c.setFillColor(colors.HexColor('#D3D3D3'))  # Exact gray
    c.setStrokeColor(colors.black)
    c.setLineWidth(0.8)  # Thinner border
    c.rect(left_x, box_y, box_width, box_height, fill=True, stroke=True)
    
    c.setFillColor(colors.black)
    notice_y = box_y + box_height - 3*mm  # Exact padding
    
    c.setFont(f"{font_family}-BoldOblique", 7)  # Exact font
    c.drawString(left_x + 1.5*mm, notice_y, "NOT TO BE PAID - DOCUMENT JUST FOR VAT MATTERS")
    
    notice_y -= 3.2*mm  # Exact spacing
    c.setFont(f"{font_family}-Oblique", 6.5)  # Exact font size
    c.drawString(left_x + 1.5*mm, notice_y, "PLEASE COMPLETE AND RETURN THIS DECLARATION BY MAIL -->")
    
    notice_y -= 3*mm  # Exact spacing
    c.drawString(left_x + 1.5*mm, notice_y, "> fiscalrepresenation@dkm-customs.com")
    
    notice_y -= 3*mm  # Exact spacing
    c.drawString(left_x + 1.5*mm, notice_y, "THANK YOU")
    
    # RIGHT COLUMN: Declaration + Signature - exact positioning
    right_x = left_x + box_width + 8*mm  # Exact spacing between columns
    right_width = width - right_x - 15*mm
    
    # Declaration text - exact formatting
    text = "Declares that the goods imported into Belgium were properly transported to the country mentioned on the left. Undersigned therefore declares that the acquisition of below mentioned goods will be reported in their VAT return according to the law of the member state which the VAT identification"
    
    c.setFont(font_family, 6.5)  # Exact font size
    lines = wrap_text(c, text, right_width, font_family, 6.5)
    
    text_y = y - 2*mm  # Exact positioning
    for line in lines[:3]:  # Limit to 3 lines max
        c.drawString(right_x, text_y, line)
        text_y -= 2.8*mm  # Exact line spacing
    
    text_y -= 2.5*mm  # Exact spacing before signature fields
    
    # Signature fields - exact positioning
    c.setFont(font_family, 7)  # Exact font size
    c.drawString(right_x, text_y, "Name of the undersigned :")
    
    text_y -= 4*mm  # Exact spacing
    c.drawString(right_x, text_y, "function of the undersigned :")
    
    text_y -= 4*mm  # Exact spacing
    c.drawString(right_x, text_y, "Signature :")
    
    return y - 32*mm  # Exact spacing to table


def draw_table(c: canvas.Canvas, data, y: float, width: float, font_family: str) -> float:
    """
    Draw table with EXACT dimensions and styling
    """
    
    if not data.line_items:
        return y
    
    # Headers - exact column names
    headers = ['MRN', 'ID', 'Supplier', 'Date', 'Reference', 'Detentors', 'Item', 'Commodity', 'Var Value €']
    
    # Create table data
    table_data = [headers]
    
    for idx, item in enumerate(data.line_items):
        if idx == 0:
            # First item - include all columns
            row = [
                data.mrn,
                str(data.declarationid),
                data.exportername,
                data.datum,
                data.reference,
                str(data.processfactuurnummer),
                str(item.zendtarieflijnnummer),
                item.goederencode,
                f"{item.verkoopwaarde:.2f}"
            ]
        else:
            # Subsequent items - empty first 6 columns
            row = [
                '', '', '', '', '', '',
                str(item.zendtarieflijnnummer),
                item.goederencode,
                f"{item.verkoopwaarde:.2f}"
            ]
        table_data.append(row)
    
    # EXACT column widths from original PDF
    col_widths = [28*mm, 15*mm, 32*mm, 16*mm, 58*mm, 20*mm, 10*mm, 23*mm, 18*mm]
    
    table = Table(table_data, colWidths=col_widths)
    
    # Calculate span for first 6 columns
    num_items = len(data.line_items)
    
    # Build EXACT style matching original
    style = [
        # Header - exact styling
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#C0C0C0')),  # Exact gray
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
        ('FONTNAME', (0, 0), (-1, 0), f'{font_family}-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 7),  # Exact font size
        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
        ('VALIGN', (0, 0), (-1, 0), 'MIDDLE'),
        
        # Data rows - exact styling
        ('FONTNAME', (0, 1), (-1, -1), font_family),
        ('FONTSIZE', (0, 1), (-1, -1), 6.5),  # Exact font size
        ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
        ('VALIGN', (0, 1), (-1, -1), 'TOP'),
        
        # Grid - exact styling
        ('GRID', (0, 0), (-1, -1), 0.5, colors.black),  # Thinner grid lines
        ('BOX', (0, 0), (-1, -1), 1, colors.black),  # Thinner outer border
        
        # Padding - exact values
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
    ]
    
    # Span first 6 columns across all item rows
    if num_items > 1:
        for col in range(6):
            style.append(('SPAN', (col, 1), (col, num_items)))
        
        # Center align values in spanned cells
        style.append(('VALIGN', (0, 1), (5, num_items), 'MIDDLE'))
        style.append(('ALIGN', (0, 1), (5, num_items), 'CENTER'))
    
    table.setStyle(TableStyle(style))
    
    table_width, table_height = table.wrap(0, 0)
    table.drawOn(c, 15*mm, y - table_height)
    
    return y - table_height - 3*mm  # Exact spacing after table


def wrap_text(c: canvas.Canvas, text: str, max_width: float, font_name: str, font_size: int) -> list:
    """Wrap text with exact measurements"""
    words = text.split()
    lines = []
    current_line = ""
    
    for word in words:
        test_line = f"{current_line} {word}".strip()
        line_width = stringWidth(test_line, font_name, font_size)
        
        if line_width <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    
    if current_line:
        lines.append(current_line)
    
    return lines

============================================================
FILE: services/state_manager.py
============================================================
import json
import logging
import os
from datetime import datetime
from azure.storage.blob import BlobServiceClient
from typing import List

CONTAINER_NAME = "document-intelligence"
FOLDER_NAME = "Bestemmingsrapport"
STATE_BLOB_NAME = "bestemmings_state.json"


def get_blob_client():
    """Get blob storage container client."""
    connect_str = os.getenv("AzureWebJobsStorage")
    if not connect_str:
        raise ValueError("Missing Azure storage connection string")
    
    blob_service = BlobServiceClient.from_connection_string(connect_str)
    return blob_service.get_container_client(CONTAINER_NAME)


def get_max_id(rows: List[dict]) -> int:
    """Find maximum INTERNFACTUURNUMMER in a batch."""
    if not rows:
        return 0
    return max([row.get("INTERNFACTUURNUMMER", 0) for row in rows])


def get_state() -> dict:
    """Reads and returns current blob state as a dict."""
    try:
        container = get_blob_client()
        blob_path = f"{FOLDER_NAME}/{STATE_BLOB_NAME}"
        blob_client = container.get_blob_client(blob_path)
        data = blob_client.download_blob().readall().decode("utf-8")
        return json.loads(data)
    except Exception:
        return {"lastProcessedId": 0, "pendingIds": [], "pendingCreated": {}}


def save_state(state: dict) -> None:
    """Writes the given state dictionary atomically to the blob."""
    container = get_blob_client()
    blob_path = f"{FOLDER_NAME}/{STATE_BLOB_NAME}"
    blob_client = container.get_blob_client(blob_path)
    blob_client.upload_blob(json.dumps(state, indent=2), overwrite=True)
    logging.info(f"✅ Blob state saved: lastProcessedId={state.get('lastProcessedId')}, pending={state.get('pendingIds')}")


def update_state(processed_ids: list[int], new_max_id: int) -> None:
    """
    Updates blob state after a successful processing run.
    """
    state = get_state()
    old_last = state.get("lastProcessedId", 0)
    old_pending = set(state.get("pendingIds", []))
    processed = set(processed_ids or [])

    # Compute new missing IDs
    missing_between = set(range(old_last + 1, new_max_id + 1)) - processed

    # Merge pending lists
    new_pending = (old_pending | missing_between) - processed

    # Add timestamps
    pending_created = state.get("pendingCreated", {})
    now_iso = datetime.utcnow().isoformat() + "Z"
    for mid in missing_between:
        pending_created[str(mid)] = now_iso
    for pid in processed:
        pending_created.pop(str(pid), None)

    # Update state
    state["lastProcessedId"] = max(old_last, new_max_id)
    state["pendingIds"] = sorted(list(new_pending))
    state["pendingCreated"] = pending_created
    state["lastRun"] = now_iso
    state["recordsProcessed"] = len(processed)

    save_state(state)

============================================================
FILE: __init__.py
============================================================
import logging
import azure.functions as func
import json
import base64
from datetime import datetime

from .services.data_transformer import transform_row
from .services.pdf_generator import generate_pdf


def main(req: func.HttpRequest) -> func.HttpResponse:
    """Main Azure Function handler"""
    logging.info("BestemmingsGenerator triggered")
    
    if req.method != "POST":
        return func.HttpResponse(
            json.dumps({"success": False, "error": "Method not allowed"}),
            status_code=405,
            mimetype="application/json"
        )
    
    try:
        body = req.get_json()
        rows = body.get("Table1", [])
        
        if not rows:
            return func.HttpResponse(
                json.dumps({
                    "success": True,
                    "message": "No data to process",
                    "processed_count": 0,
                    "pdfs": []
                }),
                status_code=200,
                mimetype="application/json"
            )
        
        logging.info(f"Processing {len(rows)} records")
        
        pdfs = []
        errors = []
        
        for row in rows:
            try:
                # Transform data
                data = transform_row(row)
                
                # Generate PDF
                pdf_bytes = generate_pdf(data)
                pdf_base64 = base64.b64encode(pdf_bytes).decode('utf-8')
                
                filename = f"{data.internfactuurnummer}-BEST-{row['DATUM']}.pdf"
                
                pdfs.append({
                    "internfactuurnummer": data.internfactuurnummer,
                    "filename": filename,
                    "pdf_base64": pdf_base64,
                    "size_bytes": len(pdf_bytes),
                    "metadata": {
                        "client": data.client.naam,
                        "datum": data.formatted_date,
                        "mrn": data.mrn,
                        "item_count": len(data.line_items)
                    }
                })
                
                logging.info(f"✅ Generated: {filename}")
                
            except Exception as e:
                logging.error(f"Failed to process record: {str(e)}")
                errors.append({
                    "internfactuurnummer": row.get("INTERNFACTUURNUMMER"),
                    "error": str(e)
                })
        
        response = {
            "success": True,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "processed_count": len(pdfs),
            "pdfs": pdfs,
            "errors": errors
        }
        
        return func.HttpResponse(
            json.dumps(response),
            status_code=200,
            mimetype="application/json"
        )
        
    except Exception as e:
        logging.error(f"❌ Critical error: {str(e)}")
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "error": str(e),
                "processed_count": 0,
                "pdfs": []
            }),
            status_code=500,
            mimetype="application/json"
        )

============================================================
FILE: function.json
============================================================
{
    "bindings": [
        {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": ["get", "post"]
        },
        {
            "type": "http",
            "direction": "out",
            "name": "$return"
        }
    ]
}